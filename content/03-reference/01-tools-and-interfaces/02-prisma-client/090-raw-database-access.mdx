---
title: 'Raw database access'
metaTitle: 'Raw database access (Reference)'
metaDescription: 'Learn how you can send raw SQL queries to your database using the raw() method from the Prisma Client API.'
---

<TopBlock>

Prisma Client exposes two methods that allow you to send raw SQL queries to your database:

- Use `queryRaw` to return actual records (for example, using `SELECT`)
- Use `executeRaw` to return a count of affected rows (for example, after an `UPDATE` or `DELETE`)

Use cases for raw SQL include:

- You are a strong SQL user and want to run a heavily optimized query
- Prisma Client does not yet support the feature that you require (please [consider raising an issue](https://github.com/prisma/prisma/issues/new/choose))

</TopBlock>

## <inlinecode>queryRaw</inlinecode>

`queryRaw` returns actual database records. For example, the following `SELECT` query returns all fields for each record in the `User` table:

```ts no-lines
const result = await prisma.queryRaw('SELECT * FROM User;')
```

The same method is implemented as a tagged template, which makes it easier to use [variables](#using-variables-and-helpers). The following example includes an `${email}` variable:

```ts no-lines
const email = "edna@prisma.io"
const result = await prisma.queryRaw`SELECT * FROM User WHERE email = ${email};`
```

### Return type

`queryRaw` returns an array. Each object corresponds to a database record:

```js
;[
  { id: 1, email: 'sarah@prisma.io', name: 'Sarah' },
  { id: 2, email: 'alice@prisma.io', name: 'Alice' },
]
```

You also [type the results of `queryRaw`](#typing-queryraw-results).

### Signature

```ts no-lines
queryRaw<T = any>(query: string | TemplateStringsArray, ...values: any[]): Promise<T>;
```

### Typing `queryRaw` results

You can adjust the return type of `queryRaw` with a [TypeScript Generic](https://www.typescriptlang.org/docs/handbook/generics.html). `queryRaw` has the following signature:

```ts no-lines
queryRaw<T = any>(query: string | TemplateStringsArray): Promise<T>;
```

`Promise<T>` uses [generic type parameter `T`](https://www.typescriptlang.org/docs/handbook/generics.html). You can determine the type of `T` when you invoke the `queryRaw` command. In the following example, `queryRaw` returns `User[]`:

```ts
// import the generated `User` type from the `@prisma/client` module
import { User } from '@prisma/client'

const result = await prisma.queryRaw<User[]>('SELECT * FROM User;')
// result is of type: `User[]`
```

> **Note**: If you do not provide a type, `queryRaw` defaults to `any`.

`result` is now `User[]` and intellisense is available:

![](https://imgur.com/H2TCRc5.png)

If you are selecting **specific fields** of the model or want to include relations, refer to the documentation about [leveraging Prisma Client's generated types](advanced-usage-of-generated-types) if you want to make sure that the results are properly typed.

#### Type caveats when using raw SQL

When you type the results of `queryRaw`, the raw data does not always match the suggested TypeScript type. For example, the following Prisma model includes a `Boolean` field named `published`:

```prisma
model Post {
  id         Int     @default(autoincrement()) @id
| published  Boolean @default(false)
  title      String
  content    String?
}
```

The following query returns all posts and prints out the value of each post's `published` property:

```ts
const result = await prisma.queryRaw<Post[]>`SELECT * FROM Post`;

result.forEach((x) => {
  console.log(x.published);
});
```

If the database provider is MySQL, the values are `1` or `0`. However, if the database provider is PostgreSQL, the values are `true`, `false`, or `NULL`.

> **Note**: The Prisma Client query engine standardises the return type for all databases.

## <inlinecode>executeRaw</inlinecode>

`executeRaw` returns the _number of rows affected by a database operation_, such as `UPDATE` or `DELETE`. This function does **not** return database records. The following query updates records in the database and returns a count of the number of records that were updated:

```ts
const result: number = await prisma.executeRaw(
  'UPDATE User SET active = true WHERE emailValidated = true;'
)
```

The same method is implemented as a tagged template, which makes it easier to use [variables](#using-variables-and-helpers):

```ts
const emailValidated = true;
const active = true;

const result: number = await prisma.executeRaw`UPDATE User SET active = ${active} WHERE emailValidated = ${emailValidated};`)
```

### Return type

`executeRaw` returns a `number`.

### Signature

```ts
executeRaw<T = any>(query: string | TemplateStringsArray, ...values: any[]): Promise<number>;
```

## Using variables

There are two ways to pass variables into `executeRaw` and `queryRaw`:

* Use the [tagged template](#variables-with-tagged-templates) implementation of either method (preferred)
* Use a [parameterized query](#parameterized-queries)

Prisma Client escapes all variables, but there are still steps you can take to further [mitigate the risk of SQL injection](#mitigating-sql-injection). 

> **Note**: You cannot pass in table or column names as variables.

### Variables with tagged templates

The following examples uses [tagged templates](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_templates) to pass variables into the SQL query. The Prisma Client implementation specifically uses [SQL Template Tag](https://github.com/blakeembrey/sql-template-tag
):

```ts
const userId = 42
const result = await prisma.queryRaw`SELECT * FROM User WHERE id = (${userId});`
```

SQL Template Tag exposes includes a number of helpers. The following example uses `join()` to pass in a list of IDs:

```ts
import { join } from "@prisma/client";

const ids = [1, 3, 5, 10, 20];
const result = await prisma.queryRaw`SELECT * FROM User WHERE id IN (${join(
  ids
)})`;
```

The following example uses the `empty` and `sql` helpers to change the query depending on whether `userName` is empty:

```ts
const userName = "";
const result = await prisma.queryRaw`SELECT * FROM User ${
  userName ? sql`WHERE name = ${userName}` : empty // Cannot use "" or NULL here!
}`;
```

Benefits of using tagged templates include:

* Tagged templates are database-agnostic - you do not need to remember if variables should be written as is `$1` (PostgreSQL) or `?` (MySQL)
* Tagged templates give you access to useful helpers like `join` and `empty`
* Embedded, named variables are easier to read

### Parameterized queries

`queryRaw` supports standard parameterized queries where each variable is represented by a symbol (`?` for mySQL, `$1`, `$2`, and so on for PostgreSQL):

```ts
const userName = "Sarah";
const email = "alice@prisma.io";
const result = await prisma.queryRaw(
  "SELECT * FROM User WHERE (name = ? OR email = ?)", // MySQL variable, represented by ?
  userName,
  email
);
```

The same query written using tagged templates is easier to read and works with all database providers:

```ts
const userName = "Sarah";
const email = "alice@prisma.io";
const result = await prisma.queryRaw`SELECT * FROM User WHERE (name = ${userName} OR email = ${email})`;
```

## SQL injection

Prisma Client mitigates the risk of SQL injection in the following ways:

* Escapes all variables and sends all queries as prepared statements.
* Executes `queryRaw()` and `executeRaw()` as a single query. You cannot append a second query - for example, adding `DROP tablename` to the end of a `SELECT`.

Do not use


```ts
const mysterString = ""
const query = "SELECT" + mysterString;
const result = await prisma.queryRaw`"SELECT * FROM User WHERE (name = ${userName} OR email = ${email})`;
```